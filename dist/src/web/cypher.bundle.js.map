{"version":3,"sources":["webpack://pandora/./src/web/domain/encryption.ts","webpack://pandora/webpack/bootstrap","webpack://pandora/./src/web/workers/cypher.ts"],"names":[],"mappings":";;;;;;;;;;AAAa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,mBAAmB,GAAG,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,iBAAiB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gEAAgE,+BAA+B;AAC/F;AACA,oEAAoE,+BAA+B;AACnG;AACA;AACA;AACA;AACA;AACA,0CAA0C,+BAA+B;AACzE;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,iFAAiF,iBAAiB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,gEAAgE,+BAA+B;AAC/F;AACA,uEAAuE,+BAA+B;AACtG;AACA,uCAAuC,+BAA+B;AACtE;AACA,mBAAmB;;;;;;;UClEnB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;;ACtBa;AACb,6BAA6C,CAAC,cAAc,CAAC;AAC7D,qBAAqB,mBAAO,CAAC,4DAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6DAA6D;AAClF;AACA;AACA;AACA;AACA;AACA;AACA","file":"cypher.bundle.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decryptFile = exports.encryptFile = void 0;\nfunction readFile(file) {\n    return new Promise((resolve, reject) => {\n        var fr = new FileReader();\n        fr.onload = () => {\n            if (!fr.result || typeof fr.result === \"string\") {\n                return reject();\n            }\n            resolve(fr.result);\n        };\n        fr.readAsArrayBuffer(file);\n    });\n}\nasync function encryptFile(objFile, encPassPhrase) {\n    const plainTextBytes = new Uint8Array(await readFile(objFile));\n    const pbkdf2iterations = 10000;\n    const passPhraseBytes = new TextEncoder().encode(encPassPhrase);\n    const pbkdf2salt = crypto.getRandomValues(new Uint8Array(8));\n    const passPhraseKey = await crypto.subtle.importKey(\"raw\", passPhraseBytes, { name: \"PBKDF2\" }, false, [\"deriveBits\"]);\n    console.log(\"passphrasekey imported\");\n    const pbkdf2bytes = new Uint8Array(await crypto.subtle.deriveBits({\n        name: \"PBKDF2\",\n        salt: pbkdf2salt,\n        iterations: pbkdf2iterations,\n        hash: \"SHA-256\",\n    }, passPhraseKey, 384));\n    console.log(\"pbkdf2bytes derived\");\n    const keyBytes = pbkdf2bytes.slice(0, 32);\n    const ivBytes = pbkdf2bytes.slice(32);\n    const key = await crypto.subtle.importKey(\"raw\", keyBytes, { name: \"AES-CBC\", length: 256 }, false, [\"encrypt\"]);\n    console.log(\"key imported\");\n    const cipherBytes = new Uint8Array(await crypto.subtle.encrypt({ name: \"AES-CBC\", iv: ivBytes }, key, plainTextBytes));\n    console.log(\"plaintext encrypted\");\n    const resultBytes = new Uint8Array(cipherBytes.length + 16);\n    resultBytes.set(new TextEncoder().encode(\"Salted__\"));\n    resultBytes.set(pbkdf2salt, 8);\n    resultBytes.set(cipherBytes, 16);\n    const blob = new Blob([resultBytes], { type: \"application/download\" });\n    return blob;\n}\nexports.encryptFile = encryptFile;\nasync function decryptFile(objFile, decPassPhrase) {\n    const cipherBytesA = new Uint8Array(await readFile(objFile));\n    const pbkdf2iterations = 10000;\n    const passPhraseBytes = new TextEncoder().encode(decPassPhrase);\n    const pbkdf2salt = cipherBytesA.slice(8, 16);\n    const passPhraseKey = await crypto.subtle.importKey(\"raw\", passPhraseBytes, { name: \"PBKDF2\" }, false, [\"deriveBits\"]);\n    console.log(\"passphrasekey imported\");\n    const pbkdf2bytes = new Uint8Array(await crypto.subtle.deriveBits({\n        name: \"PBKDF2\",\n        salt: pbkdf2salt,\n        iterations: pbkdf2iterations,\n        hash: \"SHA-256\",\n    }, passPhraseKey, 384));\n    console.log(\"pbkdf2bytes derived\");\n    const keyBytes = pbkdf2bytes.slice(0, 32);\n    const ivBytes = pbkdf2bytes.slice(32);\n    const cipherBytes = cipherBytesA.slice(16);\n    const key = await crypto.subtle.importKey(\"raw\", keyBytes, { name: \"AES-CBC\", length: 256 }, false, [\"decrypt\"]);\n    console.log(\"key imported\");\n    const plainTextBytes = new Uint8Array(await crypto.subtle.decrypt({ name: \"AES-CBC\", iv: ivBytes }, key, cipherBytes));\n    console.log(\"ciphertext decrypted\");\n    return new Blob([plainTextBytes], { type: \"application/download\" });\n}\nexports.decryptFile = decryptFile;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst encryption_1 = require(\"../domain/encryption\");\nonmessage = async function (e) {\n    console.log('Worker: Message received from main script');\n    const msg = e.data;\n    console.log(e);\n    if (msg.cmd === 'encrypt') {\n        const encryptedFile = await encryption_1.encryptFile(msg.file, msg.password);\n        // @ts-ignore\n        postMessage({ encryptedFile, name: msg.file.name, password: msg.password });\n    }\n    else {\n        const decryptedFile = await encryption_1.decryptFile(msg.file, msg.password);\n        // @ts-ignore\n        postMessage(decryptedFile);\n    }\n};\n"],"sourceRoot":""}